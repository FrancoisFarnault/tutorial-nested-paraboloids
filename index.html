<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='UTF-8' />
  <title>How to make nested paraboloids</title>
  <meta name="description" content="Nested hyperboloids - tutorial" />
  <meta name="viewport" content="width=device-width, user-scalable=no">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-okaidia.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body);"></script>

  <link rel='stylesheet' href='style.css' />
</head>

<body>

  <main>
    <section>
      <h1>How to draw nested paraboloids</h1>
      <p>On this tutorial you will see how to draw and animate nested paraboloids using the library <a
          href="p5.js">p5.js</a> with <a href="https://en.wikipedia.org/wiki/WebGL">WebGL</a>.</p>
      <div class="img_frame final"></div>
      <p>Check <a href="https://sketch.francoisfarnault.fr/cupolas/index">this webpage</a> to see the final shape in
        motion.</p>
      <p>
        The original inspiration for this drawing comes from the pinecone-like shape that
        appear at the top of <a href="https://societycentered.design">the Society Centred Design
          website</a>.</p>
      <p>
        This tutorial assumes you know javascript and that you are already in the process of learning p5.js. You can
        find useful tutorials on how to get started with this
        library <a href="https://www.youtube.com/watch?v=HerCR8bw_GE">here</a>.
      </p>
      <p>
        To write the code you may need to install a code editor such as <a href="https://code.visualstudio.com">Visual
          Studio Code</a>.
      </p>
    </section>

    <section>
      <h2>p5.js setup</h2>
      <p>A p5.js program is called a sketch and usually includes a html page and a javascript page:</p>
      <pre>
        <code class="language-html">
          &lt;!-- index.html -->
          &lt;!DOCTYPE html>
          &lt;html lang="en">

          &lt;head>
            &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js">&lt;/script>
            &lt;meta charset="utf-8" />
          &lt;/head>

          &lt;body>
            &lt;script src="sketch.js">&lt;/script>
          &lt;/body>

          &lt;/html>
        </code>
      </pre>
      <pre>
        <code class="language-javascript">
          //sketch.js
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          };
          
          function draw() {};
        </code>
      </pre>
      <p>sketch.js is the page where we are going to write the logic of our program. The first line of <a
          href="https://p5js.org/reference/#/p5/setup">\(setup()\)</a> creates a canvas at the dimensions of the
        browser's window.</p>
      <p>It also specifies that we are using a 3 dimensional coordinates system with WebGL:</p>
      <ul>
        <li>the point of coordinates \(\left({0,0,0}\right)\) is located at the center of the screen,</li>
        <li>the X axis is horizontal,</li>
        <li>the Y axis is vertical,</li>
        <li>and the Z axis goes from front to back.</li>
      </ul>
      <p>The function <a href="https://p5js.org/reference/#/p5/draw">\(draw()\)</a> comes directly after \(setup()\). If
        you are already familiar with p5.js you know that \(draw()\) is a loop that draws the image over and over again.
        This is where we are going to write the code for rendering. </p>
      <p>If you open index.html on your browser you will see a blank canvas. Let's start
        drawing on it!</p>
    </section>

    <section>
      <h2>Graphing a parabola</h2>
      <h3>Using an equation to draw a curve</h3>
      <p>Before creating shapes in 3D we are going to start by drawing curves in 2D.</p>
      <p>In this part we are going to use an equation to
        calculate the \(\left({x,y}\right)\) coordinates of a parabola:</p>
      <p>$$x^2+\left({y-f}\right)^2=\left({y+f}\right)^2$$</p>
      <small><a href="https://en.wikipedia.org/wiki/Parabola#In_a_cartesian_coordinate_system">Wikipedia
          source</a></small>
      <p>In addition to \(x\) and \(y\) this equation uses a focal length \(f\). Try
        <a href="https://codepen.io/francoisfarnault/pen/dyXGwwZ">this interactive sketch</a> to get a better sense
        of what this parameter does to the shape of the parabola.</p>
      </p>
      <p>What we are aiming for is to use this equation inside a loop so that \(y\) is calculated for every
        increment of \(x\).</p>
      <p>Rearranging to write \(y\) as a function of \(x\) we have:</p>
      <p>$$y=\frac{x^2}{4f}$$</p>
      <small><a
          href="https://www.wolframalpha.com/input/?i=solve+for+y%3A+x%5E2+%2B+%28y-f%29%5E2+%3D+%28y%2Bf%29%5E2">Equation
          solver
        </a></small>
      <p>This way of writing the equation enables us to write this function:</p>
      <pre>
        <code class="language-js">      
          let getParabolaCoordinates = (focalLength, parabolaWidth) => {
            let coordinates = [];
            for (let x = -parabolaWidth / 2; x &lt;= parabolaWidth / 2; x++) {
              let y = pow(x, 2) / (4 * focalLength);
              coordinates.push(createVector(x, y));
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>\(x\) goes from \(-parabolaWidth / 2\) to \(parabolaWidth / 2\) in order to have the curve symmetrical to a
        vertical axis. On one side of the parabola the values of \(x\) are
        negative and on the other they are positive.</p>
      <p>The function <a href="https://p5js.org/reference/#/p5/createVector">\(createVector()\)</a> binds \(x\) and
        \(y\) together.</p>
      <p>Now let's write the function that will draw a curve from this array. We can use the function <a
          href="https://p5js.org/reference/#/p5/vertex">\(vertex()\)</a> to connect all the points with segments:
      </p>
      <pre>
        <code class="language-js">      
          let drawLineFromCoordinates = (coordinates) => {
            beginShape();
            for (let point of coordinates) {
              vertex(point.x, point.y, point.z);
            }
            endShape();
          };
        </code>
      </pre>
      <p>In \(setup()\) let's set the focal length to 50 and the width to 400.</p>
      <p>Our program starts by calculating the coordinates of the parabola, then it stores them in an array outside the
        scope of \(setup()\) so that it can be reused in \(draw()\):</p>
      <pre>
        <code class="language-js">      
          let parabolaCoordinates = [];

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let focalLength = 50,
              parabolaWidth = 400;

            parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            drawLineFromCoordinates(parabolaCoordinates);
          };

          let getParabolaCoordinates = (focalLength, parabolaWidth) => { ... };
          
          let drawLineFromCoordinates = (coordinates) => { ... };
        </code>
      </pre>
      <p>If you run this program you will see this parabola: </p>
      <div class="img_frame parabola_down"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/2_parabola_down/sketch.js">Source
          code</a></small>
      <p>This is a good start. However this curve is made of with a huge amount of points very close to one another.
        Later on this will slow the process of rendering surfaces.</p>
      <p>How could we draw this curve with a lower number of points while retaining a sufficient level of definition?
      </p>
      <h3>Adjusting the curve's level of definition</h3>
      <p>
        Let’s add a new parameter to our function so that we can control the number of points per parabola:
      </p>
      <pre>
        <code class="language-js">      
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola) => {
            let coordinates = [],
              xIncrement = parabolaWidth / (pointsPerParabola - 1);
            for (let i = 0, x = -parabolaWidth / 2; i &lt; pointsPerParabola; i++, x += xIncrement) {
              let y = pow(x, 2) / (4 * focalLength);
              coordinates.push(createVector(x, y));
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>This changes a bit the logic of the function as \(x\) is now incremented by a pre-calculated interval.</p>
      <p>In \(setup()\) let's set the number of points to 9.</p>
      <p>In \(draw()\) let's use the function <a href="https://p5js.org/reference/#/p5/ellipse">\(ellipse()\)</a> to
        highlight the segmentation:
      </p>
      <pre>
        <code class="language-js">      
          let parabolaCoordinates = [];

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let focalLength = 50,
              parabolaWidth = 400,
              pointsPerParabola = 9;
          
            parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            drawLineFromCoordinates(parabolaCoordinates);
          
            fill("black");
            for (let parabolaPoint of parabolaCoordinates) {
              ellipse(parabolaPoint.x, parabolaPoint.y, 10);
            }
          };

          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola) => { ... };
          
          let drawLineFromCoordinates = (coordinates) => { ... };
        </code>
      </pre>
      <div class="img_frame segmented_parabola"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/3_parabola_segmented/sketch.js">Source
          code</a></small>
      <p>Now we can set the curve's level of definition. But there is one last thing to improve before moving on
        to 3D:</p>
      <p>With our current code all parabolas must pass through the center of the screen: the point of
        coordinates \(\left({0,0}\right)\). This will become a problem when we will need to draw several curves in a way
        that they don't touch each other.</p>
      <p>How can we modify our code to graph a parabola at a given distance from the origin of the coordinate system?
      </p>
      <h3>Positioning the curve at a given distance from the origin</h3>
      <p>Let's add a parameter to the equation of a parabola so that it takes into
        account a distance from the origin:
      </p>
      <p>$$y=\frac{x^2}{4*focalLength}+distanceFromOrigin$$</p>
      <p>Let's implement this minor change in our code:</p>
      <pre>
        <code class="language-js">      
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => {
            let coordinates = [],
              xIncrement = parabolaWidth / (pointsPerParabola - 1);
            for (let i = 0, x = -parabolaWidth / 2; i &lt; pointsPerParabola; i++, x += xIncrement) {
              let y = pow(x, 2) / (4 * focalLength) + distanceFromOrigin;
              coordinates.push(createVector(x, y));
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>In \(setup()\) let's set this distance to 50.</p>
      <p>in \(draw()\) let's use \(ellipse()\) to visualize the space
        between the curve and the origin:</p>
      <pre>
        <code class="language-js">      
          let parabolaCoordinates = [],
          origin;
        
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let focalLength = 50,
              parabolaWidth = 400,
              pointsPerParabola = 9,
              distanceFromOrigin = 50;
          
            parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin);
            origin = createVector(0, 0, 0);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            drawLineFromCoordinates(parabolaCoordinates);
          
            fill("black");
            ellipse(origin.x, origin.y, 10);
          };
          
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let drawLineFromCoordinates = (coordinates) => { ... };
        </code>
      </pre>
      <div class="img_frame distance_from_origin"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/4_distance_from_origin/sketch.js">Source
          code</a></small>
      <p>This is enough material to move from 2D to 3D. Let's make a paraboloid from this curve.</p>
    </section>

    <section>
      <h2>Drawing a paraboloid</h2>
      <p>In this part we will:</p>
      <ol>
        <li>write a function that rotates a point in 3D,</li>
        <li>use this function to rotate each point of a parabola,</li>
        <li>then use the coordinates of the rotated points to make surfaces.</li>
      </ol>
      <h3>Getting from 2D to 3D</h3>
      <p>Let's save our code in a separated file and start over from a blank canvas. We are going to start
        with a simple function that makes a circle by rotating a point in 3 dimensions.
      </p>
      <p>Here it makes sense to use cylindrical coordinates which are a 3D version of <a
          href="https://www.youtube.com/watch?v=N633bLi_YCw">polar coordinates</a>.</p>
      <p>The idea is to calculate the coordinates of a series of points forming a circle. These points are on a circle
        of radius \(p\) and have an angle of rotation \(φ\) which is incremented from 0
        to 360 degrees.</p>
      <p>Here are the equations of cylindrical coordinates for a
        revolution around the horizontal axis:</p>
      <p>$$x=x$$</p>
      <p>$$y=pcosφ$$</p>
      <p>$$z=psinφ$$</p>
      <small><a href="https://en.wikipedia.org/wiki/Cylindrical_coordinate_system#Cartesian_coordinates">Wikipedia
          source</a></small>
      <p>Let's translate this into code:</p>
      <pre>
        <code class="language-js">     
          let getCylindricalCoordinates = (point, numberOfRotations) => {
            let coordinates = [],
              x = point.x,
              radius = point.y,
              angleIncrement = TWO_PI / numberOfRotations;
            for (let i = angularPosition = 0; i &lt;= numberOfRotations; i++, angularPosition += angleIncrement) {
              let y = radius * cos(angularPosition),
                z = radius * sin(angularPosition);
              coordinates.push(createVector(x, y, z));
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>One way of looking at cylindrical coordinates is to visualize an initial point that is rotated several times
        around an axis. From this point of view \(radius\) equals \(point.y\), and \(x\) equals \(point.x\).</p>
      <p>This is where the transition from 2D to 3D occurs: the input of this function is a point with 2 dimensional
        \(\left({x,y}\right)\) coordinates, and the output is a series of points with \(\left({x,y,z}\right)\)
        coordinates.</p>
      <p>It is useful to know that with p5.js angles are in radiant by default: 360 degrees = 2&pi; radians = a full
        rotation. In p5.js the variable \(TWO\_PI\) equals 2&pi;.</p>
      <p>Now in \(setup()\) let's set arbitrary values for the coordinates of the point and for the number of rotations.
      </p>
      <pre>
          <code class="language-js">     
            let circleCoordinates = [];

            function setup() {
              createCanvas(windowWidth, windowHeight, WEBGL);
            
              let point = createVector(200, 250),
                numberOfRotations = 20;
            
              circleCoordinates = getCylindricalCoordinates(point, numberOfRotations);
            };
            
            function draw() {
              noFill();
              strokeWeight(1.5);
              drawLineFromCoordinates(circleCoordinates);
            };
            
            let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
            
            let drawLineFromCoordinates = (coordinates) => { ... };
          </code>
        </pre>
      <div class="img_frame cylindrical_coordinates"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/tree/master/steps/5_cylindrical_coordinates">Source
          code</a></small>
      <p>Now that we can rotate a point in 3D, how can we replicate this rotation for all the points of a parabola?</p>
      <h3>Drawing the sections of a paraboloid</h3>
      <p>We are going to reuse the code we wrote to calculate the coordinates of the points that make
        a parabola.</p>
      <p>Then we will write a new function that rotates these points around the
        horizontal axis. It will output a series of parallel circles that are actually the sections of a
        paraboloid.</p>
      <pre>
        <code class="language-js">      
          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => {
            let sections = [];
            for (let point of parabolaCoordinates) {
              let section = getCylindricalCoordinates(point, numberOfRotations);
              sections.push(section);
            }
            return sections;
          };
        </code>
      </pre>
      <p>Let's plug everything together:</p>
      <pre>
        <code class="language-js">      
          let parabolaCoordinates = [],
          sectionsOfParaboloid = [];
        
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let focalLength = 50,
              parabolaWidth = 400,
              pointsPerParabola = 9,
              distanceFromOrigin = 50,
              numberOfRotations = 20;
          
            parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin);
            sectionsOfParaboloid = getSectionsOfParaboloid(parabolaCoordinates, numberOfRotations);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            drawLineFromCoordinates(parabolaCoordinates);
          
            for (let section of sectionsOfParaboloid) {
              drawLineFromCoordinates(section);
            }
          };
          
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => { ... };
          
          let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
          
          let drawLineFromCoordinates = (coordinates) => { ... };
        </code>
      </pre>
      <div class="img_frame paraboloid_sections"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/6_paraboloid%20sections/sketch.js">Source
          code</a></small>
      <p>A paraboloid is taking shape! Yet it is still made of with lines while what we want is surfaces.</p>
      <p>How can we use
        these sections to generate surfaces?</p>
      <h3>Drawing the surfaces of a paraboloid</h3>
      <p>We are going to take the sections two by two and fill the space between
        them with triangles.</p>
      <p>In p5.js there is an easy way of doing this: <a
          href="https://p5js.org/reference/#/p5/beginShape">\(beginShape(TRIANGLE\_STRIP)\)</a>. It works by
        alternatively taking the coordinates of points along a first and a second line. Here is the
        pattern:</p>
      <div class="img_frame triangle_strip"></div>
      <p>This means that our code will have to go alternatively through 2 arrays of coordinates in a similar
        pattern:</p>
      <pre>
        <code class="language-js">   
          let drawTriangleStripFromTwoCurves = (coordinates1, coordinates2) => {
            beginShape(TRIANGLE_STRIP);
            for (let i = 0; i &lt; coordinates1.length; i++) {
              vertex(coordinates1[i].x, coordinates1[i].y, coordinates1[i].z);
              vertex(coordinates2[i].x, coordinates2[i].y, coordinates2[i].z);
            }
            endShape();
          };
        </code>
      </pre>
      <p>In \(draw()\) let's take the sections of paraboloid two by two and use them as an input into the above
        function:
      </p>
      <pre>
        <code class="language-js">   
          let sectionsOfParaboloid = [];

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let focalLength = 50,
              parabolaWidth = 400,
              pointsPerParabola = 9,
              distanceFromOrigin = 50,
              numberOfRotations = 20;
            let parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin);
          
            sectionsOfParaboloid = getSectionsOfParaboloid(parabolaCoordinates, numberOfRotations);
          };
          
          function draw() {
            for (let i = 0; i &lt; sectionsOfParaboloid.length - 1; i++) {
              drawTriangleStripFromTwoCurves(sectionsOfParaboloid[i], sectionsOfParaboloid[i + 1]);
            }
          };

          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => { ... };
          
          let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
  
          let drawTriangleStripFromTwoCurves = (coordinates1, coordinates2) => { ... };
        </code>
      </pre>
      <div class="img_frame paraboloid_surfaces"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/7_paraboloid_surfaces/sketch.js">Source
          code</a></small>
      <p>This is better. Now that we know how to make a single paraboloid, let's make more!</p>
    </section>

    <section>
      <h2>Graphing nested paraboloid</h2>
      <p>A quick way to add more paraboloid is to repeat the function that calculates the coordinates of a
        parabola while slightly changing the values of \(focalLength\), \(parabolaWidth\), and \(distanceFromOrigin\):
      </p>
      <pre>
        <code class="language-js">   
          let getNestedParaboloidsCoordinates = (number0fParaboloids, numberOfRotations, pointsPerParabola) => {
            let coordinates = [];
            let focalLength = 300,
              parabolaWidth = 500,
              distanceFromOrigin = 10;
          
            for (let i = 0; i &lt; number0fParaboloids; i++) {
              let parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin),
                paraboloidCoordinates = getSectionsOfParaboloid(parabolaCoordinates, numberOfRotations);
              coordinates.push(paraboloidCoordinates);
          
              focalLength -= 50;
              parabolaWidth -= 60;
              distanceFromOrigin += 20;
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>The above function adds another level of encapsulation to the
        array that contain the coordinates. The array of
        nested paraboloids is now made of 3 nested layers:
      </p>
      <pre>
        <code>   
          Nested paraboloids[
                      Paraboloid[
                                Section of paraboloid[
                                          Point0, Point1, ...
                                ]
                      ]
          ]  
        </code>
      </pre>
      <p>This structure means that we are going to use a nested loop in \(draw()\) to access the coordinates:</p>
      <pre>
        <code class="language-js">  
          let nestedParaboloidsCoordinates = [];

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let number0fParaboloids = 6,
              pointsPerParabola = 9,
              numberOfRotations = 20;
          
            nestedParaboloidsCoordinates = getNestedParaboloidsCoordinates(number0fParaboloids, numberOfRotations, pointsPerParabola);
          };
          
          function draw() {
            for (let paraboloid of nestedParaboloidsCoordinates) {
              for (let i = 0; i &lt paraboloid.length - 1; i++) {
                drawTriangleStripFromTwoCurves(paraboloid[i], paraboloid[i + 1]);
              }
            }
          };

          let getNestedParaboloidsCoordinates = (number0fParaboloids, numberOfRotations, pointsPerParabola) => { ... };

          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => { ... };
          
          let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
          
          let drawTriangleStripFromTwoCurves = (coordinates1, coordinates2) => { ... };
        </code>
      </pre>
      <div class="img_frame nested_paraboloids"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/8_nested%20paraboloids/sketch.js">Source
          code</a></small>
      <p>Nice! The pinecone-like structure is there and this shape bears some similarities with the expected result.</p>
      <p>That being said the way we set \(focalLength\), \(parabolaWidth\), and the \(distanceFromOrigin\) is imprecise
        and there isn't yet a well identified design pattern for the proportions.
      </p>
      <p>The next part will cover a few additional steps to draw the paraboloids with greater harmony and
        precision.</p>
      <p>However if you feel like this shape is satisfying enough you can skip the next part and jump directly to
        animation and rendering.</p>
    </section>

    <section>
      <h2>Setting the right proportions</h2>
      <p>Before going further let's step back and observe the shape that we are about to
        draw:</p>
      <div class="img_frame final"></div>
      <p>There is a pattern here: each paraboloid intersects a bounding circle with a constant interspace on the
        X axis.</p>
      <div class="img_frame circle_intersections"></div>
      <p>Also there is a constant interspace between each vertex on the Y axis this time. The vertices are the turning
        points of the parabolas. Their coordinates are \(\left({0,distanceFromOrigin}\right)\).</p>
      <div class="img_frame vertices_offset"></div>
      <p>These observations give us clues about the steps to take to draw this shape:</p>
      <ol>
        <li>drawing the bounding circle,</li>
        <li>drawing vertical lines to visualize the widths of each parabola.</li>
        <li>drawing the intersections between these lines and the circle,</li>
        <li>drawing the vertices,</li>
        <li>joining the dots with parabolas.</li>
      </ol>
      <div class="img_frame steps"></div>
      <p>Let's start over from a blank canvas and do this step by step:</p>
      <h3>Drawing the bounding circle</h3>
      <p>Step one is easy with the function \(ellipse()\):</p>
      <pre>
        <code class="language-js">      
          let boundingRadius = 250;

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            ellipse(0, 0, boundingRadius * 2);
          };
        </code>
      </pre>
      <div class="img_frame bounding_circle"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/9_bounding_circle/sketch.js">Source
          code</a></small>
      <h3>Visualizing the widths of the parabolas</h3>
      <p>In this part we are going to use the function <a href="https://p5js.org/reference/#/p5/line">\(line()\)</a> to
        visualize the different widths of the parabolas.</p>
      <p>More specifically we are going to visualize the absolute value of \(x\) at the endpoints of each parabola. If
        we draw two symmetrical vertical lines from these values then the space between them is the width of a parabola.
      </p>
      <p>Also the lines are arranged in a specific way: they are separated by a constant interspace and they are
        positioned at a given distance from the Y axis.</p>
      <p>In order to set their positions with precision let's add a padding from the center and a padding from the
        sides of the circle:
      </p>
      <pre>
        <code class="language-js">      
          let boundingRadius = 250;
          let valuesOfX = [];
          
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let numberOfParabolas = 6,
              centerPadding = 50,
              sidePadding = 10;
          
            valuesOfX = getValuesOfXAtParabolasEndpoints(numberOfParabolas, boundingRadius, centerPadding, sidePadding);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            ellipse(0, 0, boundingRadius * 2);
          
            for (let x of valuesOfX) {
              line(x, -300, x, 300);
              line(-x, -300, -x, 300);
            }
          };
          
          let getValuesOfXAtParabolasEndpoints = (numberOfParabolas, boundingRadius, centerPadding, sidePadding) => {
            let valuesOfX = [],
              xInterspace = (boundingRadius - centerPadding - sidePadding) / (numberOfParabolas - 1);
            for (let i = 0; i &lt; numberOfParabolas; i++) {
              valuesOfX.push(centerPadding + xInterspace * i);
            }
            return valuesOfX;
          };
        </code>
      </pre>
      <div class="img_frame vertical_lines"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/10_vertical_lines/sketch.js">Source
          code</a></small>
      <p>The next step is to find the coordinates of the intersection points between each line and the bounding
        circle.
      </p>
      <p>Actually we already have the values of \(x\) so our aim is now to
        find the values of \(y\) for each intersection point. </p>
      <h3>Getting the endpoints of the parabolas</h3>
      <p>The values of \(x\) are already known and we also have the bounding radius \(r\). This is enough to calculate
        the values of \(y\) for each intersection point with the equation of a circle:
      </p>
      <p>$$x^{2}+y^{2}=r^{2}$$</p>
      <small><a href="https://en.wikipedia.org/wiki/Circle#Equations">Wikipedia source</a></small>
      <p> Rearranging to write \(y\) as a function of \(x\) we have:</p>
      <p>$$y = ±\sqrt{r^{2} - x^{2}}$$</p>
      <small><a href="https://www.wolframalpha.com/input/?i=solve+for+y%3A+x%5E2%2By%5E2+%3D+r%5E2">Equation
          solver</a></small>
      <p>Let's add a new function to our program with the above equation:</p>
      <pre>
        <code class="language-js">      
          let getParabolasEndPoints = (valuesOfX, boundingRadius) => {
            let parabolasEndPoints = [];
            for (let x of valuesOfX) {
              let y = sqrt(pow(boundingRadius, 2) - pow(x, 2));
              parabolasEndPoints.push(createVector(x, y));
            }
            return parabolasEndPoints;
          };
        </code>
      </pre>
      <p>Then in \(draw()\) let's use the function \(ellipse()\) at the intersections:</p>
      <pre>
        <code class="language-js">      
          let boundingRadius = 250;
          let endPoints = [];
          
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let numberOfParabolas = 6,
              centerPadding = 50,
              sidePadding = 10;
            let valuesOfX = getValuesOfXAtParabolasEndpoints(numberOfParabolas, boundingRadius, centerPadding, sidePadding);
          
            endPoints = getParabolasEndPoints(valuesOfX, boundingRadius);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            ellipse(0, 0, boundingRadius * 2);
          
            fill("black");
            for (let endPoint of endPoints) {
              line(endPoint.x, -300, endPoint.x, 300);
              line(-endPoint.x, -300, -endPoint.x, 300);
              ellipse(endPoint.x, endPoint.y, 10);
              ellipse(-endPoint.x, endPoint.y, 10);
            }
          };
          
          let getValuesOfXAtParabolasEndpoints = (numberOfParabolas, boundingRadius, centerPadding, sidePadding) => { ... };
          
          let getParabolasEndPoints = (valuesOfX, boundingRadius) => { ... };
        </code>
      </pre>
      <div class="img_frame intersection_points"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/11_intersection_points/sketch.js">Source
          code</a></small>
      <p>We are going to use these endpoints to graph the parabolas. But first let's draw the
        vertices.</p>
      <h3>Setting the vertices</h3>
      <p>Let's write a function that returns a series of vertices separated by a constant interspace:</p>
      <pre>
        <code class="language-js">      
          let getParabolasVertices = (numberOfParabolas, vertexInterspace) => {
            let vertices = [];
            for (let i = 1; i &lt;= numberOfParabolas; i++) {
              let y = vertexInterspace * i;
              vertices.push(createVector(0, y));
            }
            return vertices;
          };
        </code>
      </pre>
      <p>Let's set this interspace to 15 and use \(ellipse()\) to show their positions:</p>
      <pre>
        <code class="language-js">      
          let boundingRadius = 250,
          numberOfParabolas = 6;
          let endPoints = [],
            vertices = [];
          
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let centerPadding = 50,
              sidePadding = 10,
              vertexInterspace = 15;
            let valuesOfX = getValuesOfXAtParabolasEndpoints(numberOfParabolas, boundingRadius, centerPadding, sidePadding);
          
            endPoints = getParabolasEndPoints(valuesOfX, boundingRadius);
            vertices = getParabolasVertices(numberOfParabolas, vertexInterspace);
          };
          
          function draw() {
            noFill();
            strokeWeight(3);
            ellipse(0, 0, boundingRadius * 2);
          
            fill("black");
            for (let i = 0; i &lt; numberOfParabolas; i++) {
              ellipse(endPoints[i].x, endPoints[i].y, 10);
              ellipse(-endPoints[i].x, endPoints[i].y, 10);
              ellipse(vertices[i].x, vertices[i].y, 10);
            }
          };
          
          /* ... */
        </code>
      </pre>
      <div class="img_frame vertices"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/12_vertices/sketch.js">Source
          code</a></small>
      <p>Now let's join the dots!</p>
      <h3>Drawing the parabolas</h3>
      <p>So far the function that we coded to graph a parabola took 4 arguments:
      </p>
      <ul>
        <li>\(focalLength\),</li>
        <li>\(parabolaWidth\),</li>
        <li>\(pointsPerParabola\),</li>
        <li>\(distanceFromOrigin\).</li>
      </ul>
      <p>But now after setting the right proportions we are left with these 3 parameters:</p>
      <ul>
        <li>\(endPoint\),</li>
        <li>\(vertex\),</li>
        <li>\(pointsPerParabola\).</li>
      </ul>
      <p>Note that \(focalLength\), \(parabolaWidth\) and \(distanceFromOrigin\) are missing now. We must find a way to
        retrieve these initial parameters because the equation we use still needs them to calculate the coordinates of a
        parabola:</p>
      <ul>
        <li>the number of \(pointsPerParabola\) remains unchanged,</li>
        <li>the \(parabolaWidth\) equals \(2*endPoint.x\),</li>
        <li>the \(distanceFromOrigin\) equals \(vertex.y\),</li>
        <li>but what about the\(focalLength\)?</li>
      </ul>
      <p>It turns out it is possible to calculate the value of the focal length from the coordinates of a single
        point on the parabola. Let's rearrange the equation of a parabola so that \(focalLength\) becomes a function
        of
        \(x\), \(y\) and \(distanceFromOrigin\): </p>
      <small><a href="https://www.wolframalpha.com/input/?i=solve+for+f%3A+y%3Dx%5E2%2F%284*f%29%2Bv">Equation
          solver</a></small>
      <p>$$focalLength=-\frac{x^2}{4*(distanceFromOrigin-y)}$$</p>
      <p>Translated into code it gives us something like this:</p>
      <pre>
        <code class="language-js">      
          let getFocalLengthFromPointAndDistanceFromOrigin = (point, distanceFromOrigin) => {
            return -pow(point.x, 2) / (4 * (distanceFromOrigin - point.y));
          }
        </code>
      </pre>
      <p>Which then enables us to write a new function that makes nested parabolas:</p>
      <pre>
        <code class="language-js">      
          let getNestedParabolasCoordinates = (numberOfParabolas, endPoints, pointsPerParabola, vertices) => {

            endPoints.reverse();
            let coordinates = [];
          
            for (let i = 0; i &lt; numberOfParabolas; i++) {
          
              let distanceFromOrigin = vertices[i].y,
                focalLength = getFocalLengthFromPointAndDistanceFromOrigin(endPoints[i], distanceFromOrigin),
                parabolaWidth = endPoints[i].x * 2;
          
              let parabolaCoordinates = getParabolaCoordinates(focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin);
              coordinates.push(parabolaCoordinates);
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>The array of endpoints is reversed so that the points are ordered from top to bottom. This is important
        for the coupling with the array of end-points.</p>
      <p>Let's plug everything together:</p>
      <pre>
        <code class="language-js">      
          let boundingRadius = 250,
          numberOfParabolas = 6;
          let endpoints = [],
            vertices = [],
            nestedParabolasCoordinates = [];
          
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let centerPadding = 50,
              sidePadding = 10,
              vertexInterspace = 15,
              pointsPerParabola = 9;
            let valuesOfX = getValuesOfXAtParabolasEndpoints(numberOfParabolas, boundingRadius, centerPadding, sidePadding);
          
            endPoints = getParabolasEndPoints(valuesOfX, boundingRadius);
            vertices = getParabolasVertices(numberOfParabolas, vertexInterspace);
            nestedParabolasCoordinates = getNestedParabolasCoordinates(numberOfParabolas, endPoints, pointsPerParabola, vertices);
          };
          
          function draw() {
            noFill();
            strokeWeight(1.5);
            for (let parabolaCoordinates of nestedParabolasCoordinates) {
              drawLineFromCoordinates(parabolaCoordinates);
            }
          
            // ellipse(0, 0, boundingRadius * 2);
          
            // fill("black");
            // for (let i = 0; i &lt; numberOfParabolas; i++) {
            //   ellipse(endPoints[i].x, endPoints[i].y, 10);
            //   ellipse(-endPoints[i].x, endPoints[i].y, 10);
            //   ellipse(vertices[i].x, vertices[i].y, 10);
            // }
          };
          
          /* ... */
        </code>
      </pre>
      <div class="img_frame circumscribed_parabolas_1"></div>
      <div class="img_frame circumscribed_parabolas_2"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/13_circumscribed_parabolas/sketch.js">Source
          code</a></small>
      <p>Great! We are only one step away from drawing nested paraboloids.</p>
      <h3>Drawing the hyperboloids</h3>
      <p>What we have done in the previous part changes the logic of the function that returns the coordinates of
        nested paraboloids.</p>
      <p>Now we need a function that takes a predefined set of parabolas as an input then returns
        sections of paraboloids:
      </p>
      <pre>
        <code class="language-js">      
          let getNestedParaboloidCoordinates = (nestedParabolasCoordinates, numberOfRotations) => {
            let coordinates = [];
            for (let parabolaCoordinates of nestedParabolasCoordinates) {
              let paraboloidCoordinates = getSectionsOfParaboloid(parabolaCoordinates, numberOfRotations);
              coordinates.push(paraboloidCoordinates);
            }
            return coordinates;
          };
        </code>
      </pre>
      <p>Our program now looks like this:
      </p>
      <pre>
        <code class="language-js">      
          let nestedParaboloidCoordinates = [];

          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
          
            let boundingRadius = 250,
              numberOfParabolas = 6,
              centerPadding = 50,
              sidePadding = 10,
              vertexInterspace = 15,
              pointsPerParabola = 9,
              numberOfRotations = 12;
            let valuesOfX = getValuesOfXAtParabolasEndpoints(numberOfParabolas, boundingRadius, centerPadding, sidePadding),
              endPoints = getParabolasEndPoints(valuesOfX, boundingRadius),
              vertices = getParabolasVertices(numberOfParabolas, vertexInterspace);
            let nestedParabolasCoordinates = getNestedParabolasCoordinates(numberOfParabolas, endPoints, pointsPerParabola, vertices);
          
            nestedParaboloidCoordinates = getNestedParaboloidCoordinates(nestedParabolasCoordinates, numberOfRotations);
          };
          
          function draw() {
            for (let paraboloidCoordinates of nestedParaboloidCoordinates) {
              for (let i = 0; i &lt; paraboloidCoordinates.length - 1; i++) {
                drawTriangleStripFromTwoCurves(paraboloidCoordinates[i], paraboloidCoordinates[i + 1]);
              }
            }
          };
          
          let getValuesOfXAtParabolasEndpoints = (numberOfParabolas, boundingRadius, centerPadding, sidePadding) => { ... };
          
          let getParabolasEndPoints = (valuesOfX, boundingRadius) => { ... };
          
          let getParabolasVertices = (numberOfParabolas, vertexInterspace) => { ... };
          
          let getNestedParabolasCoordinates = (numberOfParabolas, endPoints, pointsPerParabola, vertices) => { ... };
          
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let getFocalLengthFromPointAndDistanceFromOrigin = (point, distanceFromOrigin) => { ... };
          
          let getNestedParaboloidCoordinates = (nestedParabolasCoordinates, numberOfRotations) => { ... };

          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => { ... };
          
          let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
          
          let drawTriangleStripFromTwoCurves = (coordinates1, coordinates2) => { ... };
        </code>
      </pre>
      <div class="img_frame circumscribed_paraboloids"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/14_circumscribed_paraboloids/sketch.js">Source
          code</a></small>
      <p>With twelve functions this program is becoming relatively big. In the following part we are
        going focus solely on \(draw()\).</p>
    </section>

    <section>
      <h2>Animating nested paraboloids</h2>
      <p>Drawing something in motion means that on each new frame the image will slightly
        differ from the previous one.</p>
      <p>Therefore the first thing to do in \(draw()\) is to call the function
        <a href="https://p5js.org/reference/#/p5/clear">\(clear()\)</a> that erases the images previously drawn.
        Otherwise we would be adding drawings on top of each other and keeping visible the trace of movement.</p>
      <p>Between each frame we are going to use <a href="https://p5js.org/reference/#/p5/rotateX">rotateX()</a> and <a
          href="https://p5js.org/reference/#/p5/rotateZ">rotateZ()</a> simultaneously and play with a rotation speed
        to give the impression that the shape is spinning in a random manner around its center:</p>
      <pre>
        <code class="language-js">      
          let nestedParaboloidCoordinates = [],
            rotationSpeed = 0.005,
            angle = 0;

          function setup() { ... };

          function draw() {
            clear();

            angle += rotationSpeed;
            rotateX(angle);
            rotateZ(angle * 0.1);

            for (let paraboloidCoordinates of nestedParaboloidCoordinates) {
              for (let i = 0; i &lt paraboloidCoordinates.length - 1; i++) {
                drawTriangleStripFromTwoCurves(paraboloidCoordinates[i], paraboloidCoordinates[i + 1]);
              }
            }
          }; 
          
          /* ... */
        </code>
      </pre>
      <a href="https://www.youtube.com/watch?v=6TPVoB4uQCU"></a>
      <div class="img_frame animated_paraboloids"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/15_animated_paraboloids/sketch.js">Source
          code</a></small>
      <p>Drawing in motion enables a better understanding of the volume in
        space.</p>
      <p>What if we added another dimension to this shape with colors and transparencies?</p>
    </section>

    <section>
      <h2>Rendering with colors and transparencies</h2>
      <p>Let's have a look at the shape we are about to render:</p>
      <div class="img_frame final"></div>
      <p>There are two things at play here:</p>
      <ul>
        <li>a blending effect that you can see especially at the center: the colors get darker and darker when they
          overlap,</li>
        <li>and a gradient that goes from one color to another, from the inside to the outside of the shape.</li>
      </ul>
      <h3>Setting the blend mode</h3>
      <p>The blend mode <a href="https://p5js.org/reference/#/p5/blendMode">\(MULTIPLY\)</a> is relevant here because it
        makes the "heart" of the shape look contrasted and thus visible. A single line of code is needed to activate it:
      </p>
      <pre>
        <code class="language-javascript"> 
          function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            blendMode(MULTIPLY);
      
            /* ... */
          };
        </code>
      </pre>
      <p>You will find that with the current version of p5.js there is a bug with the rendering of translucent surfaces.
      </p>
      <p>Luckily there is a quick fix that I found here: <a
          href="https://github.com/processing/p5.js/issues/3736">https://github.com/processing/p5.js/issues/3736</a>.
        Adding this line of code in \(setup()\) will give the surfaces the expected look:</p>
      <pre>
        <code class="language-javascript"> 
          function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.drawingContext.disable(canvas.drawingContext.DEPTH_TEST);
            blendMode(MULTIPLY);
      
            /* ... */
          };
        </code>
      </pre>
      <h3>Setting the gradient</h3>
      <p>The idea of a gradient is to start with two colors, then to calculate all the shades in between.</p>
      <div class="img_frame color_gradient"></div>
      <p>In p5.js there is a function that does just that: <a
          href="https://p5js.org/reference/#/p5/lerpColor">\(lerpColor()\)</a>. "lerp" means "<a
          href="https://en.wikipedia.org/wiki/Linear_interpolation">linear
          interpolation</a>" which is a way to find a range of values between two values.</p>
      <p>Let's write the function that will actually make the gradient:</p>
      <pre>
        <code class="language-javascript">      
          let getInterpolatedColors = (firstColor, lastColor, numberOfColors) => {
            let gradient = [];
            for (let i = 0; i &lt; numberOfColors; i++) {
          
              interpolationFactor = (i * 100 / (numberOfColors - 1)) / 100;
              interpolationFactor.toFixed(2);

              let intermediateColor = lerpColor(firstColor, lastColor, interpolationFactor);
              gradient.push(intermediateColor);
            }
            return gradient;
          };
        </code>
      </pre>
      <p>\(lerpColor()\) takes a third argument that I call the \(interpolationFactor\). It goes between 0 and 1 and
        can be seen as a given distance between the two colors. For example:</p>
      <ul>
        <li>0.1 will be very close to the first color,</li>
        <li>0,5 will be a perfect mix between the two,</li>
        <li>and 1 will be the last color.</li>
      </ul>
      <p>\(interpolationFactor\) can be a simple
        percentage divided by 100 like in the above function, but I figured it would be useful to improve this function
        with another parameter to control the speed of the transition:</p>
      </p>
      <pre>
        <code class="language-javascript">      
          let getInterpolatedColors = (firstColor, lastColor, numberOfColors, transitionSpeed) => {
            let gradient = [];
            for (let i = 0; i &lt; numberOfColors; i++) {
          
              let interpolationFactor = ((pow(i, 1 / transitionSpeed) * 100 / (pow(numberOfColors - 1, 1 / transitionSpeed))) / 100);
              interpolationFactor.toFixed(2);

              let intermediateColor = lerpColor(firstColor, lastColor, interpolationFactor);
              gradient.push(intermediateColor);
            }
            return gradient;
          };
        </code>
      </pre>
      <p>With this change the transition between each color becomes exponential: </p>
      <ul>
        <li>if \( transitionSpeed&lt;1 \), then \( x^{1/transitionSpeed} &lt; x \)</li>
        <li>if \( transitionSpeed>1 \), then \( x^{1/transitionSpeed} > x \)</li>
      </ul>
      <small><a href="https://en.wikipedia.org/wiki/Nth_root">Wikipedia source</a></small>
      <p>This might be easier to understand with the following examples:</p>
      <table>
        <tr>
          <td>
          </td>
          <td>
            <div class="img_frame color_transition_1"></div>
          </td>
          <td>
            <div class="img_frame color_transition_2"></div>
          </td>
          <td>
            <div class="img_frame color_transition_3"></div>
          </td>
        </tr>
        <tr>
          <td>
            <p>Transition speed :</p>
          </td>
          <td>
            <p>0.5</p>
          </td>
          <td>
            <p>1</p>
          </td>
          <td>
            <p>2</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>Interpolation factors :</p>
          </td>
          <td>
            <p> </br>0
              </br>0.04
              </br>0.16
              </br>0.36
              </br>0.64
              </br>1</p>
          </td>
          <td>
            <p> </br>0
              </br>0.2
              </br>0.4
              </br>0.6
              </br>0.8
              </br>1</p>
          </td>
          <td>
            <p> </br>0
              </br>0.45
              </br>0.63
              </br>0.77
              </br>0.89
              </br>1</p>
          </td>
        </tr>
      </table>
      <p>This transition speed gives you an ultimate way to control the contrast between colors.
      </p>
      <p>Now in \(setup()\) let's declare 2 colors with the function <a
          href="https://p5js.org/reference/#/p5/color">\(color()\)</a>:</p>
      <pre>
        <code class="language-javascript"> 
          function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.drawingContext.disable(canvas.drawingContext.DEPTH_TEST);
            blendMode(MULTIPLY);
     
            /* ... */

            let firstColor = color(100, 150, 230, 0),
            lastColor = color(235, 235, 250, 0),
            numberOfColors = numberOfParabolas,
            transitionSpeed = 2.5;

            gradient = getInterpolatedColors(firstColor, lastColor, numberOfColors, transitionSpeed);
          };
        </code>
      </pre>
      <p>With p5.js the default color mode is RGB (Red, Green, Blue). Each color has a gauge that
        goes from 0 to 255.</p>
      <p>For some reason the blend mode does not work if we don't add an alpha value when declaring the colors. Here the
        alpha is set to \(0\) but any other value will do.
      </p>
      <p>The number of colors equals the number of parabolas since we want one color per paraboloid.</p>
      <!-- <p>Of course you can make your own gradient if you prefer other colors. I prepared a sketch that
        will help you to set each color transition with precision:</p>
      <p><a href="https://codepen.io/francoisfarnault/pen/MWjaVoa">https://codepen.io/francoisfarnault/pen/MWjaVoa</a>
      </p> -->
      <p>Now let's implement these changes in \(draw()\):</p>
      <h3>Drawing the shape with a gradient</h3>
      <p>Here is what our program looks like in the end:</p>
      <pre>
        <code class="language-javascript">      
          let nestedParaboloidCoordinates = [],
          colorGradient = [],
          rotationSpeed = 0.005,
          angle = 0;
        
          function setup() { ... };
          
          function draw() {
            angle += rotationSpeed;
            rotateX(angle);
            rotateZ(angle * 0.1);
          
            background("white");
            noStroke();
          
            for (let i = 0; i &lt; nestedParaboloidCoordinates.length; i++) {
          
              let paraboloidSections = nestedParaboloidCoordinates[i];
          
              for (let j = 0; j &lt; paraboloidSections.length - 1; j++) {
                fill(gradient[i]);
                drawTriangleStripFromTwoCurves(paraboloidSections[j], paraboloidSections[j + 1]);
              }
            }
          };
          
          let getValuesOfXAtParabolasEndpoints = (numberOfParabolas, boundingRadius, centerPadding, sidePadding) => { ... };
          
          let getParabolasEndPoints = (valuesOfX, boundingRadius) => { ... };
          
          let getParabolasVertices = (numberOfParabolas, vertexInterspace) => { ... };
          
          let getNestedParabolasCoordinates = (numberOfParabolas, endPoints, pointsPerParabola, vertices) => { ... };
          
          let getParabolaCoordinates = (focalLength, parabolaWidth, pointsPerParabola, distanceFromOrigin) => { ... };
          
          let getFocalLengthFromPointAndDistanceFromOrigin = (point, distanceFromOrigin) => { ... };
          
          let getNestedParaboloidCoordinates = (nestedParabolasCoordinates, numberOfRotations) => { ... };
          
          let getSectionsOfParaboloid = (parabolaCoordinates, numberOfRotations) => { ... };
          
          let getCylindricalCoordinates = (point, numberOfRotations) => { ... };
          
          let getInterpolatedColors = (firstColor, lastColor, numberOfColors, transitionSpeed) => { ... };
          
          let drawTriangleStripFromTwoCurves = (coordinates1, coordinates2) => { ... };
        </code>
      </pre>
      <p>In \(draw()\) note that \(clear()\) is replaced by <a
          href="https://p5js.org/reference/#/p5/background">\(background("white")\)</a> because otherwise the blend mode
        would not produce the expected result. </p>
      <p>Let's run this program:</p>
      <div class="img_frame final_animated"></div>
      <small><a
          href="https://github.com/FrancoisFarnault/tutorial-nested-paraboloids/blob/master/steps/16_translucent_paraboloids/sketch.js">Source
          code</a></small>
      <p>Voilà!</p>
    </section>

  </main>
</body>


</html>